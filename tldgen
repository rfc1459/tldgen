#!/usr/bin/env python

# Azzurra IRC Services TLD DFA generator
# Copyright (C) 2011 Matteo Panella <morpheus@azzurra.org>
#
# This program is free but copyrighted software; please check COPYING
# for more details.

from __future__ import with_statement
import sys
from fsm import Trie
from math import log10, ceil

# Template for the header file itself
C_HDR_TMPL = """/*
 * Azzurra IRC Services (C) 2001-2011 Azzurra IRC Network
 *
 * This program is free but copyrighted software; see COPYING for details.
 *
 * tld_tab.h - DFA state matrix for TLD check
 * THIS FILE IS AUTOGENERATED - DO NOT EDIT!
 */

#ifndef I_HAVE_A_VERY_GOOD_REASON_TO_INCLUDE_TLD_TAB_H
#error "*NEVER* *EVER* include this file unless you know what you're doing"
#endif /* I_HAVE_A_VERY_GOOD_REASON_TO_INCLUDE_TLD_TAB_H */

/* Token map */
static uint8_t dfa_token_map[] = {
    %(token_map)s
};

#define DFA_TOKEN_EPSILON   (dfa_token_map['\\0'])

#define DFA_STATE_COUNT     %(dfa_state_count)d
#define DFA_START_STATE     %(dfa_start_state_num)d
#define DFA_ACCEPT_STATE    %(dfa_accept_state_num)d
#define DFA_ILLEGAL_STATE   %(dfa_illegal_state_num)d
#define DFA_TRANSITIONS     %(dfa_transitions)d

/* DFA state matrix */
static %(state_type)s tld_dfa_matrix[DFA_STATE_COUNT][DFA_TRANSITIONS] = {
%(dfa_state_entries)s
};

/* Verify if given string is accepted by this DFA */
static char check_tld(const unsigned char *s)
{
    uint8_t token;
    %(state_type)s state = DFA_START_STATE;
    if (s == NULL)
        return 0;
    while (*s)
    {
        token = dfa_token_map[*s];
        if (token >= DFA_TRANSITIONS)
            return 0;
        /* Get next state */
        state = tld_dfa_matrix[state][token];
        if (state == DFA_ILLEGAL_STATE || state >= DFA_STATE_COUNT)
            return 0;
        s++;
    }
    return *s == '\\0' && (state == DFA_ACCEPT_STATE
        || tld_dfa_matrix[state][DFA_TOKEN_EPSILON] == DFA_ACCEPT_STATE);
}"""

# Template for token enum entries
C_ENUM_TMPL = "    %(enum_name)s = %(enum_value)d"

# Template for token mapping statements
C_MAP_STATEMENT_TMPL = """    case '%(token)c':
        return %(enum_name)s;"""

# Template for state table entries
C_DFA_ENTRY_TMPL = "    %(trans_tbl)s"

def load_tld_list(name='tlds-alpha-by-domain.txt'):
    """Parse IANA TLD file"""
    tlds = []
    with open(name, 'r') as f:
        for l in f:
            # Skip empty lines and comments
            l = l.strip()
            if len(l) == 0 or l[0] == '#':
                continue
            # Filter out IDNs
            l = l.lower()
            if l.startswith('xn--'):
                continue
            tlds.append(l.lower())

    # Sort the resulting list
    tlds.sort()
    # And return it
    return tlds

def generate_dfa(tlds):
    """Generate a DFA from given TLD list"""
    dfa = Trie()
    for tld in tlds:
        dfa.add_string(tld)
    return dfa

def fill_state_template(state, padding):
    # Encode state flags
    template_data = {}
    template_data['trans_tbl'] = '{ %s }' % (','.join(['%*s' % (padding, t) for t in state[1]]))
    return C_DFA_ENTRY_TMPL % template_data

def get_state_type(stm_len):
    """Return a C integer type suitable for state index representation"""
    if stm_len <= 0xff:
        return "uint8_t"
    elif stm_len <= 0xffff:
        return "uint16_t"
    elif stm_len <= 0xffffffff:
        print >>sys.stderr, "DFA has more than 65535 states, you should really consider using an hashtable to cut down memory usage"
        return "uint32_t"
    else:
        raise Exception("You're kidding me, right?")

def generate_token_map(tokens):
    # Initialize the map
    tmap = [len(tokens)] * 256
    for token in tokens:
        tmap[ord(token.sym)] = token.index
    tmapstr = []
    # Determine padding
    padding = int(ceil(log10(len(tokens))))
    # Break the token map into a 16x16 matrix
    return ',\n    '.join([', '.join(['%*s' % (padding, index) for index in tmap[i:i+16]]) for i in xrange(0, 256, 16)])

def build_c_header(dfa):
    """Build the header file from a given DFA instance"""
    template_data = {}
    tokens = dfa.get_tokens()
    # Create token map
    template_data['token_map'] = generate_token_map(tokens)
    # Define transition table size
    template_data['dfa_transitions'] = len(tokens)
    # Get the state matrix
    (state_matrix, start_state, accept_state, illegal_state) = dfa.get_state_matrix()
    # Define special states
    template_data['dfa_start_state_num'] = start_state
    template_data['dfa_accept_state_num'] = accept_state
    template_data['dfa_illegal_state_num'] = illegal_state
    template_data['dfa_state_count'] = len(state_matrix)
    # Get appropriate storage class for state index
    template_data['state_type'] = get_state_type(len(state_matrix))
    # Compute padding
    padding = int(ceil(log10(len(state_matrix))))
    # Serialize all states
    template_data['dfa_state_entries'] = ',\n'.join([fill_state_template(state, padding) for state in state_matrix])
    # Build template
    return C_HDR_TMPL % template_data

if __name__ == '__main__':
    tlds = load_tld_list()
    dfa = generate_dfa(tlds)
    lang = dfa.get_language()

    # Generate statistics
    with open('tld_stats.txt', 'w') as stats_out:
        print >>stats_out, "Language accepted by this DFA:"
        for l in sorted(lang):
            print >>stats_out, "    %s" % l
        dfa.print_states(stats_out)
        stats_out.flush()

    # Consistency check
    if not dfa.is_valid():
        print >>sys.stderr, "Fatal error: Generated DFA is not valid."
        print >>sys.stderr, "Please file an issue on https://github.com/rfc1459/tldgen/ and attach tld_stats.txt and tlds-alpha-by-domain.txt"
        sys.exit(1)

    tldset = frozenset(tlds)
    dfaset = frozenset(lang)
    not_accepted = tldset - dfaset
    invalid_accepts = dfaset - tldset
    if len(not_accepted) != 0 or len(invalid_accepts) != 0:
        print >>sys.stderr, "Fatal error: discrepancy between TLD list and DFA language."
        if len(not_accepted) > 0:
            print >>sys.stderr, "The following TLDs are VALID but not accepted by the DFA:"
            print >>sys.stderr, "%s\n" % '\n'.join(['  %s' % tld for tld in sorted(not_accepted)])
        if len(invalid_accepts) > 0:
            print >>sys.stderr, "The following TLDs are INVALID but would be accepted by the DFA:"
            print >>sys.stderr, "%s\n" % '\n'.join(['  %s' % tld for tld in sorted(invalid_accepts)])
        print >>sys.stderr, "Please file an issue on https://github.com/rfc1459/tldgen/ and attach tld_stats.txt and tlds-alpha-by-domain.txt"
        sys.exit(1)

    c_header = build_c_header(dfa)

    # Write C header to file
    with open('tld_tab.h', 'w') as chdr_out:
        chdr_out.write(c_header)
        chdr_out.write('\n')
        chdr_out.flush()
