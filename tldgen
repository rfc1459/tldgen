#!/usr/bin/env python

# Azzurra IRC Services TLD DFA generator
# Copyright (C) 2011 Matteo Panella <morpheus@azzurra.org>
#
# This program is free but copyrighted software; please check COPYING
# for more details.

from __future__ import with_statement
import sys
from fsm import Trie

# Template for the header file itself
C_HDR_TMPL = """/*
 * Azzurra IRC Services (C) 2001-2011 Azzurra IRC Network
 *
 * This program is free but copyrighted software; see COPYING for details.
 *
 * tld_tab.h - DFA state matrix for TLD check
 * THIS FILE IS AUTOGENERATED - DO NOT EDIT!
 */

#ifndef I_HAVE_A_VERY_GOOD_REASON_TO_INCLUDE_TLD_TAB_H
#error "*NEVER* *EVER* include this file unless you know what you're doing"
#endif /* I_HAVE_A_VERY_GOOD_REASON_TO_INCLUDE_TLD_TAB_H */

/* Token values */
typedef enum
{
    TLD_TOK_INVALID = -1,
%(token_enum)s
} tld_token_t;

#define TRANS_TBL_SIZE %(trans_tbl_size)d

/* DFA state */
typedef struct _dfa_state
{
    /* State number is implicitly defined by order in state array.
     * Also, initial state is always state 0.
     */
     unsigned final:1;                      /* Is this state final? */
     short transitions[TRANS_TBL_SIZE];     /* Transition table (indexed by token) */
} dfa_state;

/* Mapping function from character to token */
static inline tld_token_t dfa_token_value(unsigned char t)
{
    switch (t)
    {
%(token_map_statements)s
    default:
        return TLD_TOK_INVALID;
    }
}

/* DFA state matrix */
static dfa_state tld_dfa[] = {
%(dfa_state_entries)s
};

#define DFA_START_STATE     %(dfa_start_state_num)d
#define DFA_ILLEGAL_STATE   %(dfa_illegal_state_num)d

/* Verify if given string is accepted by this DFA */
static char check_tld(const unsigned char *s)
{
    tld_token_t token;
    short state = DFA_START_STATE;
    while (*s)
    {
        token = dfa_token_value(*s);
        if (token == TLD_TOK_INVALID || token >= TRANS_TBL_SIZE)
            return 0;
        /* Get next state */
        state = tld_dfa[state].transitions[token];
        if (state == DFA_ILLEGAL_STATE)
            return 0;
        s++;
    }
    return tld_dfa[state].final;
}"""

# Template for token enum entries
C_ENUM_TMPL = "    %(enum_name)s = %(enum_value)d"

# Template for token mapping statements
C_MAP_STATEMENT_TMPL = """    case '%(token)c':
        return %(enum_name)s;"""

# Template for state table entries
C_DFA_ENTRY_TMPL = "    {%(final)d, %(trans_tbl)s}"

def load_tld_list(name='tlds-alpha-by-domain.txt'):
    """Parse IANA TLD file"""
    tlds = []
    with open(name, 'r') as f:
        for l in f:
            # Skip empty lines and comments
            l = l.strip()
            if len(l) == 0 or l[0] == '#':
                continue
            # Filter out IDNs
            l = l.lower()
            if l.startswith('xn--'):
                continue
            tlds.append(l.lower())

    # Sort the resulting list
    tlds.sort()
    # And return it
    return tlds

def generate_dfa(tlds):
    """Generate a DFA from given TLD list"""
    dfa = Trie()
    for tld in tlds:
        dfa.add_string(tld)
    dfa.finalize()
    return dfa

def fill_state_template(state):
    # Encode state flags
    template_data = {}
    template_data['final'] = state[0]
    template_data['trans_tbl'] = '{%s}' % (','.join(['%d' % t for t in state[1]]))
    return C_DFA_ENTRY_TMPL % template_data

def build_c_header(dfa):
    """Build the header file from a given DFA instance"""
    template_data = {}
    tmap = dfa.get_tokens()
    # Create enum string
    template_data['token_enum'] = ',\n'.join([C_ENUM_TMPL % {'enum_name': token, 'enum_value': token.index} for token in tmap])
    # Define transition table size
    template_data['trans_tbl_size'] = len(tmap)
    # Assemble token mapping statements
    template_data['token_map_statements'] = '\n'.join([C_MAP_STATEMENT_TMPL % {'token': token.sym, 'enum_name': token} for token in tmap])
    # Get the state matrix
    state_matrix = dfa.get_state_matrix()
    template_data['dfa_start_state_num'] = 0
    template_data['dfa_illegal_state_num'] = -1
    # Serialize all states
    template_data['dfa_state_entries'] = ',\n'.join([fill_state_template(state) for state in state_matrix])
    # Build template
    return C_HDR_TMPL % template_data

if __name__ == '__main__':
    tlds = load_tld_list()
    dfa = generate_dfa(tlds)

    # Generate statistics
    with open('tld_stats.txt', 'w') as stats_out:
        print >>stats_out, "Language accepted by this DFA:"
        for l in sorted(dfa.get_language()):
            print >>stats_out, "    %s" % l
        dfa.print_states(stats_out)
        stats_out.flush()

    # Consistency check
    tldset = frozenset(tlds)
    dfaset = frozenset(dfa.get_language())
    not_accepted = tldset - dfaset
    invalid_accepts = dfaset - tldset
    if len(not_accepted) != 0 or len(invalid_accepts) != 0:
        print >>sys.stderr, "Fatal error: discrepancy between TLD list and DFA language."
        if len(not_accepted) > 0:
            print >>sys.stderr, "The following TLDs are VALID but not accepted by the DFA:"
            print >>sys.stderr, "%s\n" % '\n'.join(['  %s' % tld for tld in sorted(not_accepted)])
        if len(invalid_accepts) > 0:
            print >>sys.stderr, "The following TLDs are INVALID but would be accepted by the DFA:"
            print >>sys.stderr, "%s\n" % '\n'.join(['  %s' % tld for tld in sorted(invalid_accepts)])
        print >>sys.stderr, "Please file an issue on https://github.com/rfc1459/tldgen/ and attach tld_stats.txt and tlds-alpha-by-domain.txt"
        sys.exit(1)

    c_header = build_c_header(dfa)

    # Write C header to file
    with open('tld_tab.h', 'w') as chdr_out:
        chdr_out.write(c_header)
        chdr_out.write('\n')
        chdr_out.flush()
