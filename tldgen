#!/usr/bin/env python

# Azzurra IRC Services TLD DFA generator
# Copyright (C) 2011 Matteo Panella <morpheus@azzurra.org>
#
# This program is free but copyrighted software; please check COPYING
# for more details.

from __future__ import with_statement
import sys
from fsm import Trie

# Acceptance states (and flags)
ACCEPT_MAIL = 1
ACCEPT_HOST = 2
ACCEPT_ALL  = ACCEPT_MAIL | ACCEPT_HOST

# pseudo-TLDs used internally by some Azzurra ircds
PSEUDO_TLDS = (
    ('fw',  ACCEPT_HOST),
    ('lan', ACCEPT_ALL ),
    ('thc', ACCEPT_HOST),
)

# Template for the header file itself
C_HDR_TMPL = """/*
 * Azzurra IRC Services (C) 2001-2011 Azzurra IRC Network
 *
 * This program is free but copyrighted software; see COPYING for details.
 *
 * tld_tab.h - DFA state matrix for TLD check
 * THIS FILE IS AUTOGENERATED - DO NOT EDIT!
 */

#ifndef I_HAVE_A_VERY_GOOD_REASON_TO_INCLUDE_TLD_TAB_H
#error "*NEVER* *EVER* include this file unless you know what you're doing"
#endif /* I_HAVE_A_VERY_GOOD_REASON_TO_INCLUDE_TLD_TAB_H */

#define ACCEPT_MAIL %(accept_mail_val)d
#define ACCEPT_HOST %(accept_host_val)d

/* Token values */
enum
{
    TLD_TOK_INVALID = -1,
%(token_enum)s
};

#define TRANS_TBL_SIZE %(trans_tbl_size)d

/* DFA state */
typedef struct _dfa_state
{
    /* State number is implicitly defined by order in state array.
     * Also, initial state is always state 0.
     */
     unsigned char flags;                   /* TLD flags (0 if state is not final) */
     short transitions[TRANS_TBL_SIZE];     /* Transition table (indexed by token) */
} dfa_state;

/* Mapping function from character to token */
static inline int token_value(unsigned char t)
{
    switch (t)
    {
%(token_map_statements)s
    default:
        return TLD_TOK_INVALID;
    }
}

/* The state array itself (YIKES!) */
static dfa_state tld_dfa[] = {
%(dfa_state_entries)s
};"""

# Template for token enum entries
C_ENUM_TMPL = "    %(enum_name)s = %(enum_value)d"

# Template for token mapping statements
C_MAP_STATEMENT_TMPL = """    case '%(token)c':
        return %(enum_name)s;"""

# Template for state table entries
C_DFA_ENTRY_TMPL = "    {%(flags)d, %(trans_tbl)s}"

def load_tld_list(name='tlds-alpha-by-domain.txt'):
    """Parse IANA TLD file"""
    tlds = []
    with open(name, 'r') as f:
        for l in f:
            # Skip empty lines and comments
            l = l.strip()
            if len(l) == 0 or l[0] == '#':
                continue
            # Filter out IDNs
            if l.startswith('XN--'):
                continue
            tlds.append((l.lower(), ACCEPT_ALL))

    # Append local TLDs
    tlds.extend(PSEUDO_TLDS)
    # Sort the resulting list
    tlds.sort(lambda x, y: cmp(x[0], y[0]))
    # And return it
    return tlds

def generate_dfa(tlds):
    """Generate a DFA from given TLD list"""
    dfa = Trie()
    for tld in tlds:
        dfa.add_string(tld[0], tld[1])
    return dfa

def generate_token_map(lang):
    """Generate a token map for given language"""
    tmap = {}
    tidx = 0
    for s in lang:
        for c in s:
            if c not in tmap:
                tmap[c] = (c, tidx, 'TLD_TOK_%02d' % tidx)
                tidx += 1
    return sorted(tmap.values(), lambda x, y: cmp(x[1], y[1]))

def generate_state(token_map, state):
    # Encode state flags
    template_data = {}
    template_data['flags'] = state.fval if state.is_final and state.fval is not None else 0
    # Encode transitions list - start with all transitions being non-valid
    trans_list = [-1] * len(token_map)
    for (sym, next_states) in state.transitions.items():
        tridx = token_map[sym][0]
        assert len(next_states) == 1, "Internal DFA error: more than one transition for a symbol (BUG!)"
        trans_list[tridx] = next_states[0].statenum
    template_data['trans_tbl'] = '{%s}' % (','.join(['%d' % t for t in trans_list]))
    return C_DFA_ENTRY_TMPL % template_data

def build_c_header(dfa):
    """Build the header file from a given DFA instance"""
    template_data = {
        'accept_mail_val'       : ACCEPT_MAIL,
        'accept_host_val'       : ACCEPT_HOST,
    }
    tmap = generate_token_map(dfa.get_language())
    # Create enum string
    template_data['token_enum'] = ',\n'.join([C_ENUM_TMPL % {'enum_name': token[2], 'enum_value': token[1]} for token in tmap])
    # Define transition table size
    template_data['trans_tbl_size'] = len(tmap)
    # Assemble token mapping statements
    template_data['token_map_statements'] = '\n'.join([C_MAP_STATEMENT_TMPL % {'token': token[0], 'enum_name': token[2]} for token in tmap])
    # Now a tough one: generate the DFA state table
    states = [stm[1] for stm in sorted(dfa.statenum_map.items(), lambda x, y: cmp(x[0], y[0]))]
    # Ensure first state has statenum 0 and starting state flag set
    assert states[0].statenum == 0 and states[0].is_start, "Consistency error: first state is not the DFA root state (BUG!)"
    # Re-arrange token map
    token_map = dict([(t[0], t[1:]) for t in tmap])
    # Serialize all states
    template_data['dfa_state_entries'] = ',\n'.join([generate_state(token_map, state) for state in states])
    # Build template
    return C_HDR_TMPL % template_data

if __name__ == '__main__':
    tlds = load_tld_list()
    dfa = generate_dfa(tlds)

    # Generate statistics
    with open('tld_stats.txt', 'w') as stats_out:
        print >>stats_out, "Language accepted by this DFA:"
        for l in sorted(dfa.get_language()):
            print >>stats_out, "    %s" % l
        dfa.print_states(stats_out)
        stats_out.flush()

    # Ensure we're going to build a valid DFA
    if not dfa.is_valid():
        print >>sys.stderr, "DFA did not pass validation!\n\nPlease open an issue on https://github.com/rfc1459/tldgen\nand attach both tld_stats.txt and tlds-alpha-by-domain.txt"
        sys.exit(1)

    c_header = build_c_header(dfa)

    # Write C header to file
    with open('tld_tab.h', 'w') as chdr_out:
        chdr_out.write(c_header)
        chdr_out.write('\n')
        chdr_out.flush()
