#!/usr/bin/env python

# Azzurra IRC Services TLD DFA generator
# Copyright (C) 2011 Matteo Panella <morpheus@azzurra.org>
#
# This program is free but copyrighted software; please check COPYING
# for more details.

from __future__ import with_statement
import sys
from fsm import Trie

# Template for the header file itself
C_HDR_TMPL = """/*
 * Azzurra IRC Services (C) 2001-2011 Azzurra IRC Network
 *
 * This program is free but copyrighted software; see COPYING for details.
 *
 * tld_tab.h - DFA state matrix for TLD check
 * THIS FILE IS AUTOGENERATED - DO NOT EDIT!
 */

#ifndef I_HAVE_A_VERY_GOOD_REASON_TO_INCLUDE_TLD_TAB_H
#error "*NEVER* *EVER* include this file unless you know what you're doing"
#endif /* I_HAVE_A_VERY_GOOD_REASON_TO_INCLUDE_TLD_TAB_H */

/* Token values */
enum
{
    TLD_TOK_INVALID = -1,
%(token_enum)s
};

#define TRANS_TBL_SIZE %(trans_tbl_size)d

/* DFA state */
typedef struct _dfa_state
{
    /* State number is implicitly defined by order in state array.
     * Also, initial state is always state 0.
     */
     unsigned final:1;                      /* Is this state final? */
     short transitions[TRANS_TBL_SIZE];     /* Transition table (indexed by token) */
} dfa_state;

/* Mapping function from character to token */
static inline int token_value(unsigned char t)
{
    switch (t)
    {
%(token_map_statements)s
    default:
        return TLD_TOK_INVALID;
    }
}

/* The state array itself (YIKES!) */
static dfa_state tld_dfa[] = {
%(dfa_state_entries)s
};"""

# Template for token enum entries
C_ENUM_TMPL = "    %(enum_name)s = %(enum_value)d"

# Template for token mapping statements
C_MAP_STATEMENT_TMPL = """    case '%(token)c':
        return %(enum_name)s;"""

# Template for state table entries
C_DFA_ENTRY_TMPL = "    {%(final)d, %(trans_tbl)s}"

def load_tld_list(name='tlds-alpha-by-domain.txt'):
    """Parse IANA TLD file"""
    tlds = []
    with open(name, 'r') as f:
        for l in f:
            # Skip empty lines and comments
            l = l.strip()
            if len(l) == 0 or l[0] == '#':
                continue
            # Filter out IDNs
            l = l.lower()
            if l.startswith('xn--'):
                continue
            tlds.append(l.lower())

    # Sort the resulting list
    tlds.sort()
    # And return it
    return tlds

def generate_dfa(tlds):
    """Generate a DFA from given TLD list"""
    dfa = Trie()
    for tld in tlds:
        dfa.add_string(tld)
    return dfa

def fill_state_template(state):
    # Encode state flags
    template_data = {}
    template_data['final'] = state[0]
    template_data['trans_tbl'] = '{%s}' % (','.join(['%d' % t for t in state[1]]))
    return C_DFA_ENTRY_TMPL % template_data

def build_c_header(dfa):
    """Build the header file from a given DFA instance"""
    template_data = {}
    tmap = dfa.get_tokens()
    # Create enum string
    template_data['token_enum'] = ',\n'.join([C_ENUM_TMPL % {'enum_name': token, 'enum_value': token.index} for token in tmap])
    # Define transition table size
    template_data['trans_tbl_size'] = len(tmap)
    # Assemble token mapping statements
    template_data['token_map_statements'] = '\n'.join([C_MAP_STATEMENT_TMPL % {'token': token.sym, 'enum_name': token} for token in tmap])
    # Get the state matrix
    state_matrix = dfa.get_state_matrix()
    # Serialize all states
    template_data['dfa_state_entries'] = ',\n'.join([fill_state_template(state) for state in state_matrix])
    # Build template
    return C_HDR_TMPL % template_data

if __name__ == '__main__':
    tlds = load_tld_list()
    dfa = generate_dfa(tlds)

    # Generate statistics
    with open('tld_stats.txt', 'w') as stats_out:
        print >>stats_out, "Language accepted by this DFA:"
        for l in sorted(dfa.get_language()):
            print >>stats_out, "    %s" % l
        dfa.print_states(stats_out)
        stats_out.flush()

    # Ensure we're going to build a valid DFA
    if not dfa.is_valid():
        print >>sys.stderr, "DFA did not pass validation!\n\nPlease open an issue on https://github.com/rfc1459/tldgen\nand attach both tld_stats.txt and tlds-alpha-by-domain.txt"
        sys.exit(1)

    c_header = build_c_header(dfa)

    # Write C header to file
    with open('tld_tab.h', 'w') as chdr_out:
        chdr_out.write(c_header)
        chdr_out.write('\n')
        chdr_out.flush()
